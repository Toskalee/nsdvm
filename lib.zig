}
    
    /// Generate custom metadata format
    fn generateCustomMetadata(self: PackageGenerator, metadata: PackageMetadata, dependencies: []Dependency) !void {
        const metadata_path = try fmt.allocPrint(self.allocator, "{s}/package.toml", .{self.config.output_path});
        defer self.allocator.free(metadata_path);
        
        const file = fs.cwd().createFile(metadata_path, .{}) catch |err| {
            print("Error creating custom metadata file: {}\n", .{err});
            return err;
        };
        defer file.close();
        
        const writer = file.writer();
        
        // Write TOML format metadata
        try writer.print("[package]\n");
        try writer.print("name = \"{s}\"\n", .{metadata.name});
        
        const version_str = try metadata.version.toString(self.allocator);
        defer self.allocator.free(version_str);
        try writer.print("version = \"{s}\"\n", .{version_str});
        
        if (metadata.description) |desc| {
            try writer.print("description = \"{s}\"\n", .{desc});
        }
        
        if (metadata.author) |author| {
            try writer.print("author = \"{s}\"\n", .{author});
        }
        
        if (metadata.license) |license| {
            try writer.print("license = \"{s}\"\n", .{license});
        }
        
        if (metadata.homepage) |homepage| {
            try writer.print("homepage = \"{s}\"\n", .{homepage});
        }
        
        if (metadata.repository) |repo| {
            try writer.print("repository = \"{s}\"\n", .{repo});
        }
        
        if (dependencies.len > 0) {
            try writer.print("\n[dependencies]\n");
            for (dependencies) |dep| {
                const dep_version_str = try dep.version.toString(self.allocator);
                defer self.allocator.free(dep_version_str);
                try writer.print("{s} = \"{s}\"\n", .{ dep.name, dep_version_str });
            }
        }
    }
    
    /// Generate build files for the package
    fn generateBuildFiles(self: PackageGenerator, analysis: ProjectAnalysis, metadata: PackageMetadata) !void {
        if (self.config.verbose) {
            print("Generating build files...\n");
        }
        
        // Generate package build.zig
        try self.generatePackageBuildZig(analysis, metadata);
        
        // Copy original build.zig if it exists
        if (analysis.build_file) |build_file| {
            const target_build = try fmt.allocPrint(self.allocator, "{s}/build.zig.original", .{self.config.output_path});
            defer self.allocator.free(target_build);
            
            fs.cwd().copyFile(build_file, fs.cwd(), target_build, .{}) catch |err| {
                if (self.config.verbose) {
                    print("Warning: Could not copy original build file: {}\n", .{err});
                }
            };
        }
    }
    
    /// Generate a package-specific build.zig file
    fn generatePackageBuildZig(self: PackageGenerator, analysis: ProjectAnalysis, metadata: PackageMetadata) !void {
        const build_path = try fmt.allocPrint(self.allocator, "{s}/build.zig", .{self.config.output_path});
        defer self.allocator.free(build_path);
        
        const file = fs.cwd().createFile(build_path, .{}) catch |err| {
            print("Error creating build.zig file: {}\n", .{err});
            return err;
        };
        defer file.close();
        
        const writer = file.writer();
        
        // Write build.zig header
        try writer.print("//! Build file for {s} package\n", .{metadata.name});
        try writer.print("//! Generated by NSDVM\n\n");
        try writer.print("const std = @import(\"std\");\n");
        try writer.print("const Builder = std.build.Builder;\n");
        try writer.print("const Pkg = std.build.Pkg;\n\n");
        
        try writer.print("pub fn build(b: *Builder) void {{\n");
        
        // Set up build options
        try writer.print("    const target = b.standardTargetOptions(.{{}});\n");
        
        const optimize_mode = switch (metadata.build_options.optimize_mode) {
            .debug => "Debug",
            .release_safe => "ReleaseSafe",
            .release_fast => "ReleaseFast",
            .release_small => "ReleaseSmall",
        };
        try writer.print("    const mode = b.standardOptimizeOption(.{{ .preferred_optimize_mode = .{s} }});\n\n", .{optimize_mode});
        
        // Create library
        try writer.print("    const lib = b.addStaticLibrary(.{{\n");
        try writer.print("        .name = \"{s}\",\n", .{metadata.name});
        try writer.print("        .root_source_file = .{{ .path = \"src/main.zig\" }},\n");
        try writer.print("        .target = target,\n");
        try writer.print("        .optimize = mode,\n");
        try writer.print("    }});\n\n");
        
        // Add build options
        if (metadata.build_options.single_threaded) {
            try writer.print("    lib.single_threaded = true;\n");
        }
        
        if (metadata.build_options.strip_debug_info) {
            try writer.print("    lib.strip = true;\n");
        }
        
        if (metadata.build_options.pic) {
            try writer.print("    lib.force_pic = true;\n");
        }
        
        // Install library
        try writer.print("    b.installArtifact(lib);\n\n");
        
        // Add tests if included
        if (self.config.include_tests and analysis.test_files.len > 0) {
            try writer.print("    const tests = b.addTest(.{{\n");
            try writer.print("        .root_source_file = .{{ .path = \"test/main.zig\" }},\n");
            try writer.print("        .target = target,\n");
            try writer.print("        .optimize = mode,\n");
            try writer.print("    }});\n\n");
            
            try writer.print("    const test_step = b.step(\"test\", \"Run library tests\");\n");
            try writer.print("    test_step.dependOn(&tests.step);\n\n");
        }
        
        // Add examples if included
        if (self.config.include_examples and analysis.example_files.len > 0) {
            try writer.print("    const examples_step = b.step(\"examples\", \"Build all examples\");\n");
            
            for (analysis.example_files) |example_file| {
                // Extract example name from file path
                const example_name = if (mem.lastIndexOf(u8, example_file.path, "/")) |last_slash|
                    example_file.path[last_slash + 1..]
                else
                    example_file.path;
                
                // Remove .zig extension
                const name_without_ext = if (mem.endsWith(u8, example_name, ".zig"))
                    example_name[0..example_name.len - 4]
                else
                    example_name;
                
                try writer.print("    const {s}_example = b.addExecutable(.{{\n", .{name_without_ext});
                try writer.print("        .name = \"{s}\",\n", .{name_without_ext});
                try writer.print("        .root_source_file = .{{ .path = \"examples/{s}\" }},\n", .{example_file.path});
                try writer.print("        .target = target,\n");
                try writer.print("        .optimize = mode,\n");
                try writer.print("    }});\n");
                try writer.print("    {s}_example.addModule(\"{s}\", &lib.root_module);\n", .{ name_without_ext, metadata.name });
                try writer.print("    examples_step.dependOn(&b.addInstallArtifact({s}_example, .{{}}).step);\n\n", .{name_without_ext});
            }
        }
        
        // Add benchmarks if included
        if (self.config.include_benchmarks and analysis.benchmark_files.len > 0) {
            try writer.print("    const bench_step = b.step(\"bench\", \"Run benchmarks\");\n");
            
            for (analysis.benchmark_files) |bench_file| {
                const bench_name = if (mem.lastIndexOf(u8, bench_file.path, "/")) |last_slash|
                    bench_file.path[last_slash + 1..]
                else
                    bench_file.path;
                
                const name_without_ext = if (mem.endsWith(u8, bench_name, ".zig"))
                    bench_name[0..bench_name.len - 4]
                else
                    bench_name;
                
                try writer.print("    const {s}_bench = b.addExecutable(.{{\n", .{name_without_ext});
                try writer.print("        .name = \"{s}_bench\",\n", .{name_without_ext});
                try writer.print("        .root_source_file = .{{ .path = \"benchmarks/{s}\" }},\n", .{bench_file.path});
                try writer.print("        .target = target,\n");
                try writer.print("        .optimize = .ReleaseFast,\n");
                try writer.print("    }});\n");
                try writer.print("    {s}_bench.addModule(\"{s}\", &lib.root_module);\n", .{ name_without_ext, metadata.name });
                try writer.print("    bench_step.dependOn(&b.addRunArtifact({s}_bench).step);\n\n", .{name_without_ext});
            }
        }
        
        try writer.print("}}\n");
    }
    
    /// Generate documentation for the package
    fn generateDocumentation(self: PackageGenerator, analysis: ProjectAnalysis, metadata: PackageMetadata) !void {
        if (self.config.verbose) {
            print("Generating documentation...\n");
        }
        
        // Generate README.md
        try self.generateReadme(analysis, metadata);
        
        // Generate API documentation
        try self.generateApiDocs(analysis, metadata);
    }
    
    /// Generate README.md file
    fn generateReadme(self: PackageGenerator, analysis: ProjectAnalysis, metadata: PackageMetadata) !void {
        const readme_path = try fmt.allocPrint(self.allocator, "{s}/README.md", .{self.config.output_path});
        defer self.allocator.free(readme_path);
        
        const file = fs.cwd().createFile(readme_path, .{}) catch |err| {
            print("Error creating README.md file: {}\n", .{err});
            return err;
        };
        defer file.close();
        //! NSDVM - Zig Project to Package Converter
//! 
//! NSDVM (Zig Software Development Virtual Machine) is a comprehensive tool for converting
//! Zig projects into reusable packages that can be consumed by various Zig package managers
//! such as gyro, zigmod, and the built-in Zig package manager.
//!
//! Features:
//! - Automatic dependency analysis and resolution
//! - Build configuration validation and optimization
//! - Package metadata generation (build.zig.zon, package.json equivalents)
//! - Source code organization and cleanup
//! - Documentation generation and validation
//! - Version management and semantic versioning
//! - Cross-platform compatibility checks
//! - Security auditing of dependencies
//! - Performance profiling and optimization suggestions
//! - Integration with CI/CD pipelines
//!
//! Usage:
//! ```
//! nsdvm convert --input ./my-project --output ./my-package --format gyro
//! nsdvm validate --package ./my-package
//! nsdvm publish --package ./my-package --registry github
//! ```
//!
//! Architecture:
//! The tool is structured around several core components:
//! 1. ProjectAnalyzer - Analyzes source Zig projects
//! 2. DependencyResolver - Manages and resolves dependencies
//! 3. PackageGenerator - Creates package artifacts
//! 4. ConfigManager - Handles configuration and settings
//! 5. ValidationEngine - Validates packages and dependencies
//! 6. PublishingService - Handles package publishing
//!
//! Author: NSDVM Development Team
//! License: MIT
//! Version: 1.0.0

const std = @import("std");
const print = std.debug.print;
const ArrayList = std.ArrayList;
const HashMap = std.HashMap;
const Allocator = std.mem.Allocator;
const fs = std.fs;
const json = std.json;
const process = std.process;
const mem = std.mem;
const fmt = std.fmt;
const crypto = std.crypto;
const time = std.time;
const builtin = @import("builtin");

/// Maximum supported Zig version for package conversion
const MAX_ZIG_VERSION = "0.12.0";

/// Minimum supported Zig version for package conversion
const MIN_ZIG_VERSION = "0.10.0";

/// Default timeout for network operations (in milliseconds)
const NETWORK_TIMEOUT_MS = 30000;

/// Maximum file size for processing (in bytes)
const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB

/// Supported package manager formats
const PackageFormat = enum {
    gyro,
    zigmod,
    builtin,
    npm_like,
    custom,
    
    /// Convert string representation to enum
    pub fn fromString(str: []const u8) !PackageFormat {
        if (mem.eql(u8, str, "gyro")) return .gyro;
        if (mem.eql(u8, str, "zigmod")) return .zigmod;
        if (mem.eql(u8, str, "builtin")) return .builtin;
        if (mem.eql(u8, str, "npm")) return .npm_like;
        if (mem.eql(u8, str, "custom")) return .custom;
        return error.UnsupportedPackageFormat;
    }
    
    /// Convert enum to string representation
    pub fn toString(self: PackageFormat) []const u8 {
        return switch (self) {
            .gyro => "gyro",
            .zigmod => "zigmod",
            .builtin => "builtin",
            .npm_like => "npm",
            .custom => "custom",
        };
    }
};

/// Supported target architectures and operating systems
const Target = struct {
    arch: []const u8,
    os: []const u8,
    abi: ?[]const u8 = null,
    
    /// Create a target from the current build target
    pub fn fromBuiltin() Target {
        return Target{
            .arch = @tagName(builtin.cpu.arch),
            .os = @tagName(builtin.os.tag),
            .abi = if (builtin.abi != .none) @tagName(builtin.abi) else null,
        };
    }
    
    /// Convert target to string representation
    pub fn toString(self: Target, allocator: Allocator) ![]u8 {
        if (self.abi) |abi| {
            return fmt.allocPrint(allocator, "{s}-{s}-{s}", .{ self.arch, self.os, abi });
        } else {
            return fmt.allocPrint(allocator, "{s}-{s}", .{ self.arch, self.os });
        }
    }
};

/// Version information following semantic versioning
const Version = struct {
    major: u32,
    minor: u32,
    patch: u32,
    pre_release: ?[]const u8 = null,
    build_metadata: ?[]const u8 = null,
    
    /// Parse version string into Version struct
    pub fn parse(allocator: Allocator, version_str: []const u8) !Version {
        var parts = mem.split(u8, version_str, ".");
        
        const major_str = parts.next() orelse return error.InvalidVersionFormat;
        const minor_str = parts.next() orelse return error.InvalidVersionFormat;
        const patch_full = parts.next() orelse return error.InvalidVersionFormat;
        
        // Handle pre-release and build metadata
        var patch_str = patch_full;
        var pre_release: ?[]const u8 = null;
        var build_metadata: ?[]const u8 = null;
        
        if (mem.indexOf(u8, patch_full, "-")) |dash_idx| {
            patch_str = patch_full[0..dash_idx];
            const remainder = patch_full[dash_idx + 1..];
            
            if (mem.indexOf(u8, remainder, "+")) |plus_idx| {
                pre_release = try allocator.dupe(u8, remainder[0..plus_idx]);
                build_metadata = try allocator.dupe(u8, remainder[plus_idx + 1..]);
            } else {
                pre_release = try allocator.dupe(u8, remainder);
            }
        } else if (mem.indexOf(u8, patch_full, "+")) |plus_idx| {
            patch_str = patch_full[0..plus_idx];
            build_metadata = try allocator.dupe(u8, patch_full[plus_idx + 1..]);
        }
        
        return Version{
            .major = try fmt.parseInt(u32, major_str, 10),
            .minor = try fmt.parseInt(u32, minor_str, 10),
            .patch = try fmt.parseInt(u32, patch_str, 10),
            .pre_release = pre_release,
            .build_metadata = build_metadata,
        };
    }
    
    /// Convert version to string representation
    pub fn toString(self: Version, allocator: Allocator) ![]u8 {
        var result = try fmt.allocPrint(allocator, "{d}.{d}.{d}", .{ self.major, self.minor, self.patch });
        
        if (self.pre_release) |pre| {
            const old_result = result;
            result = try fmt.allocPrint(allocator, "{s}-{s}", .{ old_result, pre });
            allocator.free(old_result);
        }
        
        if (self.build_metadata) |build| {
            const old_result = result;
            result = try fmt.allocPrint(allocator, "{s}+{s}", .{ old_result, build });
            allocator.free(old_result);
        }
        
        return result;
    }
    
    /// Compare two versions for sorting
    pub fn compare(self: Version, other: Version) std.math.Order {
        if (self.major != other.major) return std.math.order(self.major, other.major);
        if (self.minor != other.minor) return std.math.order(self.minor, other.minor);
        if (self.patch != other.patch) return std.math.order(self.patch, other.patch);
        
        // Pre-release versions have lower precedence
        if (self.pre_release == null and other.pre_release != null) return .gt;
        if (self.pre_release != null and other.pre_release == null) return .lt;
        if (self.pre_release != null and other.pre_release != null) {
            return mem.order(u8, self.pre_release.?, other.pre_release.?);
        }
        
        return .eq;
    }
};

/// Dependency information for a package
const Dependency = struct {
    name: []const u8,
    version: Version,
    source: DependencySource,
    optional: bool = false,
    dev_only: bool = false,
    
    /// Source location for a dependency
    const DependencySource = union(enum) {
        registry: []const u8,
        git: GitSource,
        local: []const u8,
        url: []const u8,
        
        const GitSource = struct {
            url: []const u8,
            branch: ?[]const u8 = null,
            tag: ?[]const u8 = null,
            commit: ?[]const u8 = null,
        };
    };
    
    /// Validate dependency configuration
    pub fn validate(self: Dependency) !void {
        if (self.name.len == 0) return error.EmptyDependencyName;
        
        switch (self.source) {
            .git => |git| {
                if (git.url.len == 0) return error.EmptyGitUrl;
                // Only one of branch, tag, or commit should be specified
                const ref_count = @as(u8, if (git.branch != null) 1 else 0) +
                                 @as(u8, if (git.tag != null) 1 else 0) +
                                 @as(u8, if (git.commit != null) 1 else 0);
                if (ref_count > 1) return error.MultipleGitReferences;
            },
            .local => |path| {
                if (path.len == 0) return error.EmptyLocalPath;
            },
            .url => |url| {
                if (url.len == 0) return error.EmptyUrl;
            },
            .registry => |registry| {
                if (registry.len == 0) return error.EmptyRegistry;
            },
        }
    }
};

/// Package metadata containing all necessary information for package managers
const PackageMetadata = struct {
    name: []const u8,
    version: Version,
    description: ?[]const u8 = null,
    author: ?[]const u8 = null,
    license: ?[]const u8 = null,
    homepage: ?[]const u8 = null,
    repository: ?[]const u8 = null,
    keywords: [][]const u8 = &[_][]const u8{},
    dependencies: []Dependency = &[_]Dependency{},
    dev_dependencies: []Dependency = &[_]Dependency{},
    supported_targets: []Target = &[_]Target{},
    minimum_zig_version: ?Version = null,
    maximum_zig_version: ?Version = null,
    build_options: BuildOptions = BuildOptions{},
    
    /// Build configuration options
    const BuildOptions = struct {
        enable_lto: bool = false,
        optimize_mode: OptimizeMode = .debug,
        strip_debug_info: bool = false,
        single_threaded: bool = false,
        use_llvm: bool = true,
        use_lld: bool = true,
        pic: bool = false,
        pie: bool = false,
        sanitize_thread: bool = false,
        sanitize_address: bool = false,
        sanitize_undefined: bool = false,
        red_zone: bool = true,
        omit_frame_pointer: bool = false,
        
        const OptimizeMode = enum {
            debug,
            release_safe,
            release_fast,
            release_small,
        };
    };
    
    /// Validate package metadata
    pub fn validate(self: PackageMetadata) !void {
        if (self.name.len == 0) return error.EmptyPackageName;
        
        // Validate package name format (similar to npm naming conventions)
        for (self.name) |c| {
            if (!std.ascii.isAlphanumeric(c) and c != '-' and c != '_' and c != '.') {
                return error.InvalidPackageNameCharacter;
            }
        }
        
        // Validate dependencies
        for (self.dependencies) |dep| {
            try dep.validate();
        }
        
        for (self.dev_dependencies) |dep| {
            try dep.validate();
        }
        
        // Validate version constraints
        if (self.minimum_zig_version) |min_ver| {
            if (self.maximum_zig_version) |max_ver| {
                if (min_ver.compare(max_ver) == .gt) {
                    return error.InvalidVersionRange;
                }
            }
        }
    }
};

/// File information for tracking project files
const FileInfo = struct {
    path: []const u8,
    size: u64,
    hash: [32]u8, // SHA-256 hash
    is_source: bool,
    is_test: bool,
    is_example: bool,
    is_benchmark: bool,
    dependencies: [][]const u8 = &[_][]const u8{}, // Import dependencies
    
    /// Calculate SHA-256 hash of file content
    pub fn calculateHash(allocator: Allocator, file_path: []const u8) ![32]u8 {
        const file = fs.cwd().openFile(file_path, .{}) catch |err| {
            print("Error opening file {s}: {}\n", .{ file_path, err });
            return err;
        };
        defer file.close();
        
        var hasher = crypto.hash.sha2.Sha256.init(.{});
        var buffer: [4096]u8 = undefined;
        
        while (true) {
            const bytes_read = file.readAll(buffer[0..]) catch |err| {
                print("Error reading file {s}: {}\n", .{ file_path, err });
                return err;
            };
            
            if (bytes_read == 0) break;
            hasher.update(buffer[0..bytes_read]);
        }
        
        var result: [32]u8 = undefined;
        hasher.final(&result);
        return result;
    }
    
    /// Analyze file to extract import dependencies
    pub fn analyzeDependencies(allocator: Allocator, file_path: []const u8) ![][]const u8 {
        const file_content = fs.cwd().readFileAlloc(allocator, file_path, MAX_FILE_SIZE) catch |err| {
            print("Error reading file {s}: {}\n", .{ file_path, err });
            return &[_][]const u8{};
        };
        defer allocator.free(file_content);
        
        var dependencies = ArrayList([]const u8).init(allocator);
        errdefer {
            for (dependencies.items) |dep| {
                allocator.free(dep);
            }
            dependencies.deinit();
        }
        
        var lines = mem.split(u8, file_content, "\n");
        while (lines.next()) |line| {
            const trimmed = mem.trim(u8, line, " \t\r\n");
            
            // Look for @import statements
            if (mem.startsWith(u8, trimmed, "const ") or mem.startsWith(u8, trimmed, "var ")) {
                if (mem.indexOf(u8, trimmed, "@import(")) |import_start| {
                    const import_content_start = import_start + 8; // Length of "@import("
                    if (mem.indexOf(u8, trimmed[import_content_start..], ")")) |end_offset| {
                        const import_content = trimmed[import_content_start..import_content_start + end_offset];
                        
                        // Remove quotes
                        if (import_content.len >= 2 and 
                            import_content[0] == '"' and 
                            import_content[import_content.len - 1] == '"') {
                            const import_name = import_content[1..import_content.len - 1];
                            
                            // Skip standard library imports and relative imports
                            if (!mem.startsWith(u8, import_name, "std") and 
                                !mem.startsWith(u8, import_name, ".") and
                                !mem.startsWith(u8, import_name, "/")) {
                                try dependencies.append(try allocator.dupe(u8, import_name));
                            }
                        }
                    }
                }
            }
        }
        
        return dependencies.toOwnedSlice();
    }
};

/// Project analysis results
const ProjectAnalysis = struct {
    root_path: []const u8,
    build_file: ?[]const u8 = null,
    source_files: []FileInfo,
    test_files: []FileInfo,
    example_files: []FileInfo,
    benchmark_files: []FileInfo,
    documentation_files: []FileInfo,
    configuration_files: []FileInfo,
    total_size: u64,
    line_count: u64,
    dependency_graph: HashMap([]const u8, [][]const u8, std.hash_map.StringContext, std.hash_map.default_max_load_percentage),
    
    /// Initialize project analysis
    pub fn init(allocator: Allocator, root_path: []const u8) ProjectAnalysis {
        return ProjectAnalysis{
            .root_path = root_path,
            .source_files = &[_]FileInfo{},
            .test_files = &[_]FileInfo{},
            .example_files = &[_]FileInfo{},
            .benchmark_files = &[_]FileInfo{},
            .documentation_files = &[_]FileInfo{},
            .configuration_files = &[_]FileInfo{},
            .total_size = 0,
            .line_count = 0,
            .dependency_graph = HashMap([]const u8, [][]const u8, std.hash_map.StringContext, std.hash_map.default_max_load_percentage).init(allocator),
        };
    }
    
    /// Clean up allocated resources
    pub fn deinit(self: *ProjectAnalysis, allocator: Allocator) void {
        // Free file info arrays
        allocator.free(self.source_files);
        allocator.free(self.test_files);
        allocator.free(self.example_files);
        allocator.free(self.benchmark_files);
        allocator.free(self.documentation_files);
        allocator.free(self.configuration_files);
        
        // Free dependency graph
        var iterator = self.dependency_graph.iterator();
        while (iterator.next()) |entry| {
            allocator.free(entry.key_ptr.*);
            for (entry.value_ptr.*) |dep| {
                allocator.free(dep);
            }
            allocator.free(entry.value_ptr.*);
        }
        self.dependency_graph.deinit();
    }
};

/// Configuration for the NSDVM tool
const Config = struct {
    input_path: []const u8,
    output_path: []const u8,
    package_format: PackageFormat,
    include_tests: bool = true,
    include_examples: bool = true,
    include_benchmarks: bool = false,
    include_documentation: bool = true,
    optimize_for_size: bool = false,
    strip_debug_info: bool = false,
    validate_dependencies: bool = true,
    generate_checksums: bool = true,
    verbose: bool = false,
    dry_run: bool = false,
    parallel_processing: bool = true,
    max_parallel_jobs: u32 = 0, // 0 = auto-detect
    
    /// Load configuration from file
    pub fn loadFromFile(allocator: Allocator, config_path: []const u8) !Config {
        const config_content = fs.cwd().readFileAlloc(allocator, config_path, MAX_FILE_SIZE) catch |err| switch (err) {
            error.FileNotFound => {
                print("Configuration file not found: {s}\n", .{config_path});
                return getDefault();
            },
            else => return err,
        };
        defer allocator.free(config_content);
        
        var parser = json.Parser.init(allocator, false);
        defer parser.deinit();
        
        var tree = parser.parse(config_content) catch |err| {
            print("Error parsing configuration file: {}\n", .{err});
            return getDefault();
        };
        defer tree.deinit();
        
        // Parse JSON configuration
        var config = getDefault();
        
        if (tree.root.Object.get("input_path")) |input| {
            if (input == .String) {
                config.input_path = try allocator.dupe(u8, input.String);
            }
        }
        
        if (tree.root.Object.get("output_path")) |output| {
            if (output == .String) {
                config.output_path = try allocator.dupe(u8, output.String);
            }
        }
        
        if (tree.root.Object.get("package_format")) |format| {
            if (format == .String) {
                config.package_format = PackageFormat.fromString(format.String) catch .builtin;
            }
        }
        
        if (tree.root.Object.get("verbose")) |verbose| {
            if (verbose == .Bool) {
                config.verbose = verbose.Bool;
            }
        }
        
        return config;
    }
    
    /// Get default configuration
    pub fn getDefault() Config {
        return Config{
            .input_path = ".",
            .output_path = "./package",
            .package_format = .builtin,
        };
    }
    
    /// Validate configuration
    pub fn validate(self: Config) !void {
        if (self.input_path.len == 0) return error.EmptyInputPath;
        if (self.output_path.len == 0) return error.EmptyOutputPath;
        
        // Check if input path exists
        fs.cwd().access(self.input_path, .{}) catch |err| switch (err) {
            error.FileNotFound => return error.InputPathNotFound,
            else => return err,
        };
    }
};

/// Main project analyzer for scanning and analyzing Zig projects
const ProjectAnalyzer = struct {
    allocator: Allocator,
    config: Config,
    
    /// Initialize project analyzer
    pub fn init(allocator: Allocator, config: Config) ProjectAnalyzer {
        return ProjectAnalyzer{
            .allocator = allocator,
            .config = config,
        };
    }
    
    /// Analyze a Zig project and return comprehensive analysis results
    pub fn analyze(self: ProjectAnalyzer) !ProjectAnalysis {
        if (self.config.verbose) {
            print("Starting project analysis for: {s}\n", .{self.config.input_path});
        }
        
        var analysis = ProjectAnalysis.init(self.allocator, self.config.input_path);
        
        // Find and analyze build.zig file
        const build_zig_path = try fmt.allocPrint(self.allocator, "{s}/build.zig", .{self.config.input_path});
        defer self.allocator.free(build_zig_path);
        
        fs.cwd().access(build_zig_path, .{}) catch |err| switch (err) {
            error.FileNotFound => {
                if (self.config.verbose) {
                    print("Warning: No build.zig file found\n");
                }
            },
            else => return err,
        };
        
        analysis.build_file = try self.allocator.dupe(u8, build_zig_path);
        
        // Recursively scan project directory
        try self.scanDirectory(&analysis, self.config.input_path, "");
        
        // Build dependency graph
        try self.buildDependencyGraph(&analysis);
        
        if (self.config.verbose) {
            print("Analysis complete. Found:\n");
            print("  - {d} source files\n", .{analysis.source_files.len});
            print("  - {d} test files\n", .{analysis.test_files.len});
            print("  - {d} example files\n", .{analysis.example_files.len});
            print("  - {d} benchmark files\n", .{analysis.benchmark_files.len});
            print("  - Total size: {d} bytes\n", .{analysis.total_size});
            print("  - Total lines: {d}\n", .{analysis.line_count});
        }
        
        return analysis;
    }
    
    /// Recursively scan directory for project files
    fn scanDirectory(self: ProjectAnalyzer, analysis: *ProjectAnalysis, base_path: []const u8, relative_path: []const u8) !void {
        const full_path = if (relative_path.len == 0) 
            base_path 
        else 
            try fmt.allocPrint(self.allocator, "{s}/{s}", .{ base_path, relative_path });
        
        defer if (relative_path.len > 0) self.allocator.free(full_path);
        
        var dir = fs.cwd().openIterableDir(full_path, .{}) catch |err| {
            if (self.config.verbose) {
                print("Warning: Cannot open directory {s}: {}\n", .{ full_path, err });
            }
            return;
        };
        defer dir.close();
        
        var iterator = dir.iterate();
        var source_files = ArrayList(FileInfo).init(self.allocator);
        var test_files = ArrayList(FileInfo).init(self.allocator);
        var example_files = ArrayList(FileInfo).init(self.allocator);
        var benchmark_files = ArrayList(FileInfo).init(self.allocator);
        var doc_files = ArrayList(FileInfo).init(self.allocator);
        var config_files = ArrayList(FileInfo).init(self.allocator);
        
        while (try iterator.next()) |entry| {
            const entry_path = if (relative_path.len == 0)
                try fmt.allocPrint(self.allocator, "{s}", .{entry.name})
            else
                try fmt.allocPrint(self.allocator, "{s}/{s}", .{ relative_path, entry.name });
            defer self.allocator.free(entry_path);
            
            const full_entry_path = try fmt.allocPrint(self.allocator, "{s}/{s}", .{ base_path, entry_path });
            defer self.allocator.free(full_entry_path);
            
            switch (entry.kind) {
                .Directory => {
                    // Skip common directories that shouldn't be included in packages
                    if (mem.eql(u8, entry.name, ".git") or 
                        mem.eql(u8, entry.name, ".svn") or
                        mem.eql(u8, entry.name, "node_modules") or
                        mem.eql(u8, entry.name, "zig-cache") or
                        mem.eql(u8, entry.name, "zig-out")) {
                        continue;
                    }
                    
                    // Recursively scan subdirectories
                    try self.scanDirectory(analysis, base_path, entry_path);
                },
                .File => {
                    const stat = fs.cwd().statFile(full_entry_path) catch |err| {
                        if (self.config.verbose) {
                            print("Warning: Cannot stat file {s}: {}\n", .{ full_entry_path, err });
                        }
                        continue;
                    };
                    
                    // Skip files that are too large
                    if (stat.size > MAX_FILE_SIZE) {
                        if (self.config.verbose) {
                            print("Warning: Skipping large file {s} ({d} bytes)\n", .{ full_entry_path, stat.size });
                        }
                        continue;
                    }
                    
                    var file_info = FileInfo{
                        .path = try self.allocator.dupe(u8, entry_path),
                        .size = stat.size,
                        .hash = FileInfo.calculateHash(self.allocator, full_entry_path) catch [_]u8{0} ** 32,
                        .is_source = false,
                        .is_test = false,
                        .is_example = false,
                        .is_benchmark = false,
                    };
                    
                    // Categorize file based on extension and path
                    if (mem.endsWith(u8, entry.name, ".zig")) {
                        file_info.dependencies = FileInfo.analyzeDependencies(self.allocator, full_entry_path) catch &[_][]const u8{};
                        
                        if (mem.indexOf(u8, entry_path, "test")) |_| {
                            file_info.is_test = true;
                            try test_files.append(file_info);
                        } else if (mem.indexOf(u8, entry_path, "example")) |_| {
                            file_info.is_example = true;
                            try example_files.append(file_info);
                        } else if (mem.indexOf(u8, entry_path, "benchmark") or mem.indexOf(u8, entry_path, "bench")) |_| {
                            file_info.is_benchmark = true;
                            try benchmark_files.append(file_info);
                        } else {
                            file_info.is_source = true;
                            try source_files.append(file_info);
                        }
                        
                        // Count lines of code
                        analysis.line_count += self.countLines(full_entry_path) catch 0;
                    } else if (mem.endsWith(u8, entry.name, ".md") or 
                              mem.endsWith(u8, entry.name, ".txt") or
                              mem.endsWith(u8, entry.name, ".rst")) {
                        try doc_files.append(file_info);
                    } else if (mem.eql(u8, entry.name, "build.zig") or
                              mem.eql(u8, entry.name, "build.zig.zon") or
                              mem.endsWith(u8, entry.name, ".json") or
                              mem.endsWith(u8, entry.name, ".yaml") or
                              mem.endsWith(u8, entry.name, ".yml") or
                              mem.endsWith(u8, entry.name, ".toml")) {
                        try config_files.append(file_info);
                    }
                    
                    analysis.total_size += stat.size;
                },
                else => {}, // Skip other file types
            }
        }
        
        // Merge collected files into analysis
        const old_source = analysis.source_files;
        const old_test = analysis.test_files;
        const old_example = analysis.example_files;
        const old_benchmark = analysis.benchmark_files;
        const old_doc = analysis.documentation_files;
        const old_config = analysis.configuration_files;
        
        // Combine old and new file lists
        analysis.source_files = try self.combineFileArrays(old_source, source_files.items);
        analysis.test_files = try self.combineFileArrays(old_test, test_files.items);
        analysis.example_files = try self.combineFileArrays(old_example, example_files.items);
        analysis.benchmark_files = try self.combineFileArrays(old_benchmark, benchmark_files.items);
        analysis.documentation_files = try self.combineFileArrays(old_doc, doc_files.items);
        analysis.configuration_files = try self.combineFileArrays(old_config, config_files.items);
        
        // Free temporary arrays
        source_files.deinit();
        test_files.deinit();
        example_files.deinit();
        benchmark_files.deinit();
        doc_files.deinit();
        config_files.deinit();
    }
    
    /// Combine two file arrays into a single array
    fn combineFileArrays(self: ProjectAnalyzer, existing: []FileInfo, new_files: []FileInfo) ![]FileInfo {
        if (existing.len == 0) {
            return try self.allocator.dupe(FileInfo, new_files);
        }
        
        if (new_files.len == 0) {
            return existing;
        }
        
        var combined = ArrayList(FileInfo).init(self.allocator);
        try combined.appendSlice(existing);
        try combined.appendSlice(new_files);
        
        // Free the old array if it's not empty
        if (existing.len > 0) {
            self.allocator.free(existing);
        }
        
        return combined.toOwnedSlice();
    }
    
    /// Count lines in a file
    fn countLines(self: ProjectAnalyzer, file_path: []const u8) !u64 {
        const content = fs.cwd().readFileAlloc(self.allocator, file_path, MAX_FILE_SIZE) catch |err| {
            if (self.config.verbose) {
                print("Warning: Cannot read file {s} for line counting: {}\n", .{ file_path, err });
            }
            return 0;
        };
        defer self.allocator.free(content);
        
        var line_count: u64 = 0;
        for (content) |c| {
            if (c == '\n') line_count += 1;
        }
        
        // Add 1 if file doesn't end with newline
        if (content.len > 0 and content[content.len - 1] != '\n') {
            line_count += 1;
        }
        
        return line_count;
    }
    
    /// Build dependency graph from analyzed files
    fn buildDependencyGraph(self: ProjectAnalyzer, analysis: *ProjectAnalysis) !void {
        if (self.config.verbose) {
            print("Building dependency graph...\n");
        }
        
        // Process all source files
        for (analysis.source_files) |file| {
            if (file.dependencies.len > 0) {
                const deps_copy = try self.allocator.dupe([]const u8, file.dependencies);
                try analysis.dependency_graph.put(try self.allocator.dupe(u8, file.path), deps_copy);
            }
        }
        
        // Process test files if included
        if (self.config.include_tests) {
            for (analysis.test_files) |file| {
                if (file.dependencies.len > 0) {
                    const deps_copy = try self.allocator.dupe([]const u8, file.dependencies);
                    try analysis.dependency_graph.put(try self.allocator.dupe(u8, file.path), deps_copy);
                }
            }
        }
    }
};

/// Dependency resolver for managing external dependencies
const DependencyResolver = struct {
    allocator: Allocator,
    config: Config,
    registry_cache: HashMap([]const u8, PackageMetadata, std.hash_map.StringContext, std.hash_map.default_max_load_percentage),
    
    /// Initialize dependency resolver
    pub fn init(allocator: Allocator, config: Config) DependencyResolver {
        return DependencyResolver{
            .allocator = allocator,
            .config = config,
            .registry_cache = HashMap([]const u8, PackageMetadata, std.hash_map.StringContext, std.hash_map.default_max_load_percentage).init(allocator),
        };
    }
    
    /// Clean up allocated resources
    pub fn deinit(self: *DependencyResolver) void {
        var iterator = self.registry_cache.iterator();
        while (iterator.next()) |entry| {
            self.allocator.free(entry.key_ptr.*);
        }
        self.registry_cache.deinit();
    }
    
    /// Resolve all dependencies for a project
    pub fn resolve(self: *DependencyResolver, analysis: ProjectAnalysis) ![]Dependency {
        if (self.config.verbose) {
            print("Resolving dependencies...\n");
        }
        
        var all_deps = ArrayList(Dependency).init(self.allocator);
        errdefer {
            for (all_deps.items) |dep| {
                self.allocator.free(dep.name);
            }
            all_deps.deinit();
        }
        
        var dep_names = HashMap([]const u8, void, std.hash_map.StringContext, std.hash_map.default_max_load_percentage).init(self.allocator);
        defer dep_names.deinit();
        
        // Extract unique dependency names from all files
        var graph_iterator = analysis.dependency_graph.iterator();
        while (graph_iterator.next()) |entry| {
            for (entry.value_ptr.*) |dep_name| {
                if (!dep_names.contains(dep_name)) {
                    try dep_names.put(dep_name, {});
                    
                    // Try to resolve this dependency
                    if (self.resolveDependency(dep_name)) |dependency| {
                        try all_deps.append(dependency);
                        
                        if (self.config.verbose) {
                            print("  Resolved dependency: {s} v{}\n", .{ dependency.name, dependency.version });
                        }
                    } else |err| {
                        if (self.config.verbose) {
                            print("  Warning: Could not resolve dependency {s}: {}\n", .{ dep_name, err });
                        }
                        
                        // Create a placeholder dependency for unknown packages
                        try all_deps.append(Dependency{
                            .name = try self.allocator.dupe(u8, dep_name),
                            .version = Version{ .major = 0, .minor = 0, .patch = 0 },
                            .source = .{ .registry = "unknown" },
                            .optional = true,
                        });
                    }
                }
            }
        }
        
        return all_deps.toOwnedSlice();
    }
    
    /// Resolve a single dependency by name
    fn resolveDependency(self: *DependencyResolver, dep_name: []const u8) !Dependency {
        // Check cache first
        if (self.registry_cache.get(dep_name)) |cached_metadata| {
            return Dependency{
                .name = try self.allocator.dupe(u8, dep_name),
                .version = cached_metadata.version,
                .source = .{ .registry = "cached" },
            };
        }
        
        // Try to resolve from various sources
        
        // 1. Check if it's a standard library module
        if (self.isStandardLibrary(dep_name)) {
            return Dependency{
                .name = try self.allocator.dupe(u8, dep_name),
                .version = Version{ .major = 0, .minor = 12, .patch = 0 }, // Current Zig version
                .source = .{ .registry = "std" },
            };
        }
        
        // 2. Try local package managers (gyro, zigmod)
        if (self.resolveFromPackageManager(dep_name)) |dep| {
            return dep;
        } else |_| {}
        
        // 3. Try git repositories (common naming patterns)
        if (self.resolveFromGit(dep_name)) |dep| {
            return dep;
        } else |_| {}
        
        return error.DependencyNotFound;
    }
    
    /// Check if a name refers to a standard library module
    fn isStandardLibrary(self: DependencyResolver, name: []const u8) bool {
        _ = self;
        
        const std_modules = [_][]const u8{
            "std", "builtin", "root",
        };
        
        for (std_modules) |module| {
            if (mem.eql(u8, name, module)) return true;
        }
        
        return false;
    }
    
    /// Try to resolve dependency from package managers
    fn resolveFromPackageManager(self: *DependencyResolver, dep_name: []const u8) !Dependency {
        // Look for gyro.zzz or deps.zig files
        const gyro_path = try fmt.allocPrint(self.allocator, "{s}/gyro.zzz", .{self.config.input_path});
        defer self.allocator.free(gyro_path);
        
        if (fs.cwd().access(gyro_path, .{})) {
            return self.parseGyroFile(gyro_path, dep_name);
        } else |_| {}
        
        const deps_path = try fmt.allocPrint(self.allocator, "{s}/deps.zig", .{self.config.input_path});
        defer self.allocator.free(deps_path);
        
        if (fs.cwd().access(deps_path, .{})) {
            return self.parseDepsFile(deps_path, dep_name);
        } else |_| {}
        
        return error.DependencyNotFound;
    }
    
    /// Parse gyro.zzz file to find dependencies
    fn parseGyroFile(self: *DependencyResolver, file_path: []const u8, dep_name: []const u8) !Dependency {
        const content = fs.cwd().readFileAlloc(self.allocator, file_path, MAX_FILE_SIZE) catch {
            return error.DependencyNotFound;
        };
        defer self.allocator.free(content);
        
        // Simple parsing for gyro.zzz format
        var lines = mem.split(u8, content, "\n");
        while (lines.next()) |line| {
            const trimmed = mem.trim(u8, line, " \t\r\n");
            
            if (mem.indexOf(u8, trimmed, dep_name)) |_| {
                // Extract version information if available
                if (mem.indexOf(u8, trimmed, "version")) |version_start| {
                    const version_part = trimmed[version_start + 7..]; // Skip "version"
                    
                    // Parse version string
                    var version_iter = mem.tokenize(u8, version_part, " \t\"'");
                    if (version_iter.next()) |version_str| {
                        const version = Version.parse(self.allocator, version_str) catch 
                            Version{ .major = 0, .minor = 0, .patch = 1 };
                        
                        return Dependency{
                            .name = try self.allocator.dupe(u8, dep_name),
                            .version = version,
                            .source = .{ .registry = "gyro" },
                        };
                    }
                }
            }
        }
        
        return error.DependencyNotFound;
    }
    
    /// Parse deps.zig file to find dependencies
    fn parseDepsFile(self: *DependencyResolver, file_path: []const u8, dep_name: []const u8) !Dependency {
        const content = fs.cwd().readFileAlloc(self.allocator, file_path, MAX_FILE_SIZE) catch {
            return error.DependencyNotFound;
        };
        defer self.allocator.free(content);
        
        // Simple parsing for deps.zig format
        var lines = mem.split(u8, content, "\n");
        while (lines.next()) |line| {
            const trimmed = mem.trim(u8, line, " \t\r\n");
            
            if (mem.indexOf(u8, trimmed, dep_name)) |_| {
                return Dependency{
                    .name = try self.allocator.dupe(u8, dep_name),
                    .version = Version{ .major = 0, .minor = 0, .patch = 1 },
                    .source = .{ .registry = "zigmod" },
                };
            }
        }
        
        return error.DependencyNotFound;
    }
    
    /// Try to resolve dependency from common Git repositories
    fn resolveFromGit(self: *DependencyResolver, dep_name: []const u8) !Dependency {
        // Common GitHub patterns for Zig packages
        const common_repos = [_][]const u8{
            "https://github.com/ziglibs/{s}",
            "https://github.com/zig-community/{s}",
            "https://github.com/{s}/{s}",
        };
        
        for (common_repos) |pattern| {
            const repo_url = if (mem.count(u8, pattern, "{s}") == 2)
                try fmt.allocPrint(self.allocator, pattern, .{ dep_name, dep_name })
            else
                try fmt.allocPrint(self.allocator, pattern, .{dep_name});
            
            defer self.allocator.free(repo_url);
          
            return Dependency{
                .name = try self.allocator.dupe(u8, dep_name),
                .version = Version{ .major = 0, .minor = 1, .patch = 0 },
                .source = .{ .git = .{ .url = try self.allocator.dupe(u8, repo_url) } },
            };
        }
        
        return error.DependencyNotFound;
    }
};

/// Package generator for creating package artifacts
const PackageGenerator = struct {
    allocator: Allocator,
    config: Config,
    
    /// Initialize package generator
    pub fn init(allocator: Allocator, config: Config) PackageGenerator {
        return PackageGenerator{
            .allocator = allocator,
            .config = config,
        };
    }
    
    /// Generate package from project analysis
    pub fn generate(self: PackageGenerator, analysis: ProjectAnalysis, metadata: PackageMetadata, dependencies: []Dependency) !void {
        if (self.config.verbose) {
            print("Generating package in format: {s}\n", .{self.config.package_format.toString()});
        }
        
        // Create output directory
        fs.cwd().makeDir(self.config.output_path) catch |err| switch (err) {
            error.PathAlreadyExists => {}, // Directory already exists, that's fine
            else => return err,
        };
        
        // Copy source files
        try self.copySourceFiles(analysis);
        
        // Generate package metadata files
        try self.generatePackageMetadata(metadata, dependencies);
        
        // Generate build files
        try self.generateBuildFiles(analysis, metadata);
        
        // Generate documentation
        if (self.config.include_documentation) {
            try self.generateDocumentation(analysis, metadata);
        }
        
        // Generate checksums if requested
        if (self.config.generate_checksums) {
            try self.generateChecksums(analysis);
        }
        
        if (self.config.verbose) {
            print("Package generation complete!\n");
        }
    }
    
    /// Copy source files to package directory
    fn copySourceFiles(self: PackageGenerator, analysis: ProjectAnalysis) !void {
        if (self.config.verbose) {
            print("Copying source files...\n");
        }
        
        // Create source directory structure
        const src_dir = try fmt.allocPrint(self.allocator, "{s}/src", .{self.config.output_path});
        defer self.allocator.free(src_dir);
        
        fs.cwd().makeDir(src_dir) catch |err| switch (err) {
            error.PathAlreadyExists => {},
            else => return err,
        };
        
        // Copy source files
        for (analysis.source_files) |file| {
            try self.copyFile(file.path, "src");
        }
        
        // Copy test files if included
        if (self.config.include_tests) {
            const test_dir = try fmt.allocPrint(self.allocator, "{s}/test", .{self.config.output_path});
            defer self.allocator.free(test_dir);
            
            fs.cwd().makeDir(test_dir) catch |err| switch (err) {
                error.PathAlreadyExists => {},
                else => return err,
            };
            
            for (analysis.test_files) |file| {
                try self.copyFile(file.path, "test");
            }
        }
        
        // Copy example files if included
        if (self.config.include_examples) {
            const examples_dir = try fmt.allocPrint(self.allocator, "{s}/examples", .{self.config.output_path});
            defer self.allocator.free(examples_dir);
            
            fs.cwd().makeDir(examples_dir) catch |err| switch (err) {
                error.PathAlreadyExists => {},
                else => return err,
            };
            
            for (analysis.example_files) |file| {
                try self.copyFile(file.path, "examples");
            }
        }
        
        // Copy benchmark files if included
        if (self.config.include_benchmarks) {
            const bench_dir = try fmt.allocPrint(self.allocator, "{s}/benchmarks", .{self.config.output_path});
            defer self.allocator.free(bench_dir);
            
            fs.cwd().makeDir(bench_dir) catch |err| switch (err) {
                error.PathAlreadyExists => {},
                else => return err,
            };
            
            for (analysis.benchmark_files) |file| {
                try self.copyFile(file.path, "benchmarks");
            }
        }
        
        // Copy documentation files
        if (self.config.include_documentation) {
            const docs_dir = try fmt.allocPrint(self.allocator, "{s}/docs", .{self.config.output_path});
            defer self.allocator.free(docs_dir);
            
            fs.cwd().makeDir(docs_dir) catch |err| switch (err) {
                error.PathAlreadyExists => {},
                else => return err,
            };
            
            for (analysis.documentation_files) |file| {
                try self.copyFile(file.path, "docs");
            }
        }
    }
    
    /// Copy a single file to the package directory
    fn copyFile(self: PackageGenerator, relative_path: []const u8, target_subdir: []const u8) !void {
        const source_path = try fmt.allocPrint(self.allocator, "{s}/{s}", .{ self.config.input_path, relative_path });
        defer self.allocator.free(source_path);
        
        // Create target directory structure
        const target_path = try fmt.allocPrint(self.allocator, "{s}/{s}/{s}", .{ self.config.output_path, target_subdir, relative_path });
        defer self.allocator.free(target_path);
        
        // Create parent directories
        if (fs.path.dirname(target_path)) |parent_dir| {
            fs.cwd().makePath(parent_dir) catch |err| switch (err) {
                error.PathAlreadyExists => {},
                else => return err,
            };
        }
        
        // Copy file
        fs.cwd().copyFile(source_path, fs.cwd(), target_path, .{}) catch |err| {
            if (self.config.verbose) {
                print("Warning: Could not copy file {s}: {}\n", .{ source_path, err });
            }
        };
    }
    
    /// Generate package metadata files based on format
    fn generatePackageMetadata(self: PackageGenerator, metadata: PackageMetadata, dependencies: []Dependency) !void {
        if (self.config.verbose) {
            print("Generating package metadata...\n");
        }
        
        switch (self.config.package_format) {
            .builtin => try self.generateBuiltinMetadata(metadata, dependencies),
            .gyro => try self.generateGyroMetadata(metadata, dependencies),
            .zigmod => try self.generateZigmodMetadata(metadata, dependencies),
            .npm_like => try self.generateNpmLikeMetadata(metadata, dependencies),
            .custom => try self.generateCustomMetadata(metadata, dependencies),
        }
    }
    
    /// Generate build.zig.zon for built-in package manager
    fn generateBuiltinMetadata(self: PackageGenerator, metadata: PackageMetadata, dependencies: []Dependency) !void {
        const metadata_path = try fmt.allocPrint(self.allocator, "{s}/build.zig.zon", .{self.config.output_path});
        defer self.allocator.free(metadata_path);
        
        const file = fs.cwd().createFile(metadata_path, .{}) catch |err| {
            print("Error creating metadata file: {}\n", .{err});
            return err;
        };
        defer file.close();
        
        const writer = file.writer();
        
        // Write build.zig.zon content
        try writer.print(".{{\n");
        try writer.print("    .name = \"{s}\",\n", .{metadata.name});
        
        const version_str = try metadata.version.toString(self.allocator);
        defer self.allocator.free(version_str);
        try writer.print("    .version = \"{s}\",\n", .{version_str});
        
        if (metadata.description) |desc| {
            try writer.print("    .description = \"{s}\",\n", .{desc});
        }
        
        if (metadata.author) |author| {
            try writer.print("    .author = \"{s}\",\n", .{author});
        }
        
        if (metadata.license) |license| {
            try writer.print("    .license = \"{s}\",\n", .{license});
        }
        
        if (metadata.homepage) |homepage| {
            try writer.print("    .homepage = \"{s}\",\n", .{homepage});
        }
        
        if (metadata.minimum_zig_version) |min_ver| {
            const min_ver_str = try min_ver.toString(self.allocator);
            defer self.allocator.free(min_ver_str);
            try writer.print("    .minimum_zig_version = \"{s}\",\n", .{min_ver_str});
        }
        
        // Write dependencies
        if (dependencies.len > 0) {
            try writer.print("    .dependencies = .{{\n");
            for (dependencies) |dep| {
                try writer.print("        .{s} = .{{\n", .{dep.name});
                
                const dep_version_str = try dep.version.toString(self.allocator);
                defer self.allocator.free(dep_version_str);
                try writer.print("            .version = \"{s}\",\n", .{dep_version_str});
                
                switch (dep.source) {
                    .registry => |registry| try writer.print("            .registry = \"{s}\",\n", .{registry}),
                    .git => |git| {
                        try writer.print("            .url = \"{s}\",\n", .{git.url});
                        if (git.branch) |branch| try writer.print("            .branch = \"{s}\",\n", .{branch});
                        if (git.tag) |tag| try writer.print("            .tag = \"{s}\",\n", .{tag});
                        if (git.commit) |commit| try writer.print("            .commit = \"{s}\",\n", .{commit});
                    },
                    .local => |path| try writer.print("            .path = \"{s}\",\n", .{path}),
                    .url => |url| try writer.print("            .url = \"{s}\",\n", .{url}),
                }
                
                try writer.print("        }},\n");
            }
            try writer.print("    }},\n");
        }
        
        try writer.print("}}\n");
    }
    
    /// Generate gyro.zzz for Gyro package manager
    fn generateGyroMetadata(self: PackageGenerator, metadata: PackageMetadata, dependencies: []Dependency) !void {
        const metadata_path = try fmt.allocPrint(self.allocator, "{s}/gyro.zzz", .{self.config.output_path});
        defer self.allocator.free(metadata_path);
        
        const file = fs.cwd().createFile(metadata_path, .{}) catch |err| {
            print("Error creating gyro metadata file: {}\n", .{err});
            return err;
        };
        defer file.close();
        
        const writer = file.writer();
        
        // Write gyro.zzz content
        try writer.print("pkgs:\n");
        
        for (dependencies) |dep| {
            try writer.print("  {s}:\n", .{dep.name});
            
            const dep_version_str = try dep.version.toString(self.allocator);
            defer self.allocator.free(dep_version_str);
            try writer.print("    version: {s}\n", .{dep_version_str});
            
            switch (dep.source) {
                .git => |git| {
                    try writer.print("    src:\n");
                    try writer.print("      git: {s}\n", .{git.url});
                    if (git.branch) |branch| try writer.print("      ref: {s}\n", .{branch});
                    if (git.tag) |tag| try writer.print("      ref: {s}\n", .{tag});
                    if (git.commit) |commit| try writer.print("      ref: {s}\n", .{commit});
                },
                .url => |url| {
                    try writer.print("    src:\n");
                    try writer.print("      url: {s}\n", .{url});
                },
                else => {},
            }
        }
    }
    
    /// Generate deps.zig for Zigmod package manager
    fn generateZigmodMetadata(self: PackageGenerator, metadata: PackageMetadata, dependencies: []Dependency) !void {
        _ = metadata;
        
        const deps_path = try fmt.allocPrint(self.allocator, "{s}/deps.zig", .{self.config.output_path});
        defer self.allocator.free(deps_path);
        
        const file = fs.cwd().createFile(deps_path, .{}) catch |err| {
            print("Error creating deps.zig file: {}\n", .{err});
            return err;
        };
        defer file.close();
        
        const writer = file.writer();
        
        // Write deps.zig content
        try writer.print("// Generated by NSDVM\n");
        try writer.print("const std = @import(\"std\");\n\n");
        try writer.print("pub fn addAllTo(exe: *std.build.LibExeObjStep) void {{\n");
        
        for (dependencies) |dep| {
            try writer.print("    exe.addPackagePath(\"{s}\", \".gyro/{s}/src/main.zig\");\n", .{ dep.name, dep.name });
        }
        
        try writer.print("}}\n");
    }
    
    /// Generate package.json for NPM-like package management
    fn generateNpmLikeMetadata(self: PackageGenerator, metadata: PackageMetadata, dependencies: []Dependency) !void {
        const package_path = try fmt.allocPrint(self.allocator, "{s}/package.json", .{self.config.output_path});
        defer self.allocator.free(package_path);
        
        const file = fs.cwd().createFile(package_path, .{}) catch |err| {
            print("Error creating package.json file: {}\n", .{err});
            return err;
        };
        defer file.close();
        
        const writer = file.writer();
        
        // Write package.json content
        try writer.print("{{\n");
        try writer.print("  \"name\": \"{s}\",\n", .{metadata.name});
        
        const version_str = try metadata.version.toString(self.allocator);
        defer self.allocator.free(version_str);
        try writer.print("  \"version\": \"{s}\",\n", .{version_str});
        
        if (metadata.description) |desc| {
            try writer.print("  \"description\": \"{s}\",\n", .{desc});
        }
        
        if (metadata.author) |author| {
            try writer.print("  \"author\": \"{s}\",\n", .{author});
        }
        
        if (metadata.license) |license| {
            try writer.print("  \"license\": \"{s}\",\n", .{license});
        }
        
        if (metadata.homepage) |homepage| {
            try writer.print("  \"homepage\": \"{s}\",\n", .{homepage});
        }
        
        if (metadata.repository) |repo| {
            try writer.print("  \"repository\": \"{s}\",\n", .{repo});
        }
        
        if (metadata.keywords.len > 0) {
            try writer.print("  \"keywords\": [");
            for (metadata.keywords, 0..) |keyword, i| {
                if (i > 0) try writer.print(", ");
                try writer.print("\"{s}\"", .{keyword});
            }
            try writer.print("],\n");
        }
        
        // Write dependencies
        if (dependencies.len > 0) {
            try writer.print("  \"dependencies\": {{\n");
            for (dependencies, 0..) |dep, i| {
                const dep_version_str = try dep.version.toString(self.allocator);
                defer self.allocator.free(dep_version_str);
                
                try writer.print("    \"{s}\": \"{s}\"", .{ dep.name, dep_version_str });
                if (i < dependencies.len - 1) try writer.print(",");
                try writer.print("\n");
            }
            try writer.print("  }},\n");
        }
      
